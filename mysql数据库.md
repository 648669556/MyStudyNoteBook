## 前言

最近开始读 `高性能mysql`这本书，便整理一下知识，来巩固一下知识点，以后忘记来可以快速捡起来。我这里就记录，我个人认为比较有意思和重要的地方。

## MySql 架构与历史

### Mysql的逻辑架构

![image-20210407155139861](C:\Users\陈俊宏\AppData\Roaming\Typora\typora-user-images\image-20210407155139861.png)

- 最上面一层是 客户端和服务器之间进行连接的，连接处理呀，授权认证呀，安全等待
- 第二层是核心的层，mysql的 查询解析、分析、优化、缓存以及所有的内置函数的地方。
- 第三层就是我们的存储引擎拉。

### 数据库事务的ACID

- 原子性（atomicity）
  - 就是说这个事务，要么做了，要么没有做。
- 一致性（consistency）
  - 数据库的状态从一个状态到另外一个状态，不会一半事务完成了，一半没有完成！
- 隔离性（isolation）
  - 一个事务在提交前，其他事务是看不到的。
- 持久性（durability）
  - 事务一旦提交就会被永久保存到数据库中。即使数据库崩溃修改的数据也不会丢失。

### 事务的隔离级别

隔离性比想象当中的复杂，在SQL标准中定义了四种隔离级别，每一种级别都规定了事务中所做的修改。

1.  未提交读 （READ UNCOMMIT)
   - 在事务没有提交之前，其他的事务就可以读取到你这个事务里面所作的修改，这也被称为`“脏读”`，这个级别会产生很多的问题，而且性能不一定好。所以如果不是不得已，不要使用这种。
2. 提交读（READ COMMITED)
   - 提交读就具备了初步的隔离定义，他只有在事务提交之后才会被其他的事务所读取到。这个级别有时候也被称为 `”不可重复读“`,毕竟重复读的话，可能就会导致读到两次不一样的。
   - 例如一个事务A还未结束，但是有其他事务B已经提交两次，这事务A读取到的数据就是不一样的。还是`"脏读"`.
3. 可重复读（REPEATABLE READ)
   - 可重复度就是，在事务开始之后读取到的东西都是一样的 ，在这个事务内不管读多少遍都是一样的。这个解决了`“脏读”`的问题。但是还有另外一个问题不能被解决。那就是`幻读`!!比如说，你已经读取了一个范围的数据，例如“SELECT　＊　FROM users;” 这样的语句，但是在你事务还没结束的时候，有另外一个事务执行了并且完成了 “INSERT INTO users() values()” ，你这个事务里面第二次去读取的时候，就会产生`幻行`! 这个问题，在`InnoDb` 和 `XtrDb` 已经通过 `MVCC（多版本并发控制解决了）`。
4. 可串行化（SERIALIZABLE ）
   - 这个字母意思就是，把所有的事务都通过并行的方式执行，相当于 多线程变成了单线程，当然不会产生并发问题。但是同时肯定就会通过加锁的方式。执行效率感人。😥

### 多版本并发控制 MVCC

MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念

#### 隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段

- DB_TRX_ID
   6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID

- DB_ROLL_PTR
   7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）

- DB_ROW_ID
   6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引

- 实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了

  ![img](https:////upload-images.jianshu.io/upload_images/3133209-b45e9ebf0a3d8b14.png?imageMogr2/auto-orient/strip|imageView2/2/w/927)

如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本

#### undo日志

undo log主要分为两种：

- insert undo log
   代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃
- update undo log
   事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除

> purge
>
> - 从前面的分析可以看出，为了实现`InnoDB`的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。
> - 为了节省磁盘空间，`InnoDB`有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。

对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：

一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL

![img](https:////upload-images.jianshu.io/upload_images/3133209-e52ee5ae248c5a08.png?imageMogr2/auto-orient/strip|imageView2/2/w/833)

二、 现在来了一个事务1对该记录的name做出了修改，改为Tom

- 在事务1修改该行(记录)数据时，数据库会先对该行加排他锁

- 然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本

- 拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它

- 事务提交后，释放锁

  ![img](https:////upload-images.jianshu.io/upload_images/3133209-3b89396902dbf513.png?imageMogr2/auto-orient/strip|imageView2/2/w/843)

三、 又来了个事务2修改person表的同一个记录，将age修改为30岁

- 在事务2修改该行数据时，数据库也先为该行加锁

- 然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面

- 修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录

- 事务提交，释放锁

  ![img](https:////upload-images.jianshu.io/upload_images/3133209-70cdae4621d5543e.png?imageMogr2/auto-orient/strip|imageView2/2/w/838)

从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）

#### Read View(读视图)

###### 什么是Read View?

什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本

那么这个判断条件是什么呢？

![img](https:////upload-images.jianshu.io/upload_images/3133209-37bbaeadbb77f36c.png?imageMogr2/auto-orient/strip|imageView2/2/w/720)

如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较

在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性

> trx_list（名字我随便取的）
>  一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID
>  up_limit_id
>  记录trx_list列表中事务ID最小的ID
>  low_limit_id
>  ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1

- 首先比较DB_TRX_ID < up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断
- 接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断
- 判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的

#### 整体流程

我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了

整体的流程是怎么样的呢？我们可以模拟一下

- 当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list

  ![img](https:////upload-images.jianshu.io/upload_images/3133209-cbf70159f8628101.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

- Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图

  ![img](https:////upload-images.jianshu.io/upload_images/3133209-1d56c923cf5c6cad.png?imageMogr2/auto-orient/strip|imageView2/2/w/696)

- 我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。

  ![img](https:////upload-images.jianshu.io/upload_images/3133209-615fefab74cacee0.png?imageMogr2/auto-orient/strip|imageView2/2/w/761)

- 所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本

  ![img](https:////upload-images.jianshu.io/upload_images/3133209-be5885051c52fb6a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

- 也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同



## Schema 与数据类型优化

### 数据类型选择的原则

1. 更小的通常更好
   - 选择更加小的数据类型，一般你的 系统的cpu占用，内存缓存等等都会更小，可以让你储存更加多的数据
2. 简单就好
   - 简单的数据类型会使用更加少的cpu周期，例如 整形就比字符串操作的类型更加简单，因为字符串还有字符集和校对规则之类的问题。或者你就应该使用datatime时间类型来储存时间，而不是字符串！用整形来存储IP地址之类的。
3. 尽量避免Null
   - 如果查询中包含可以为null的列，对MYSQL来说更难优化，因为可为NULL的列使得索引、索引统计和值都更加复杂，而且可为Null的列会占用更多的空间。当然在建表后将NULL变为NOT NULL的提升并不大。

### 整形类型

整形有那么几种 ： 

- TINYINT    8
- SMALLINT  16
- MEDIUMINT  24
- INT 32 
- BIGINT 64

上面跟在后面的是他们存储所占用的位数，他们的范围是 -2^(N-1) 到 2^(N-1)-1 N为位数

整数类型有可选的 `UNSIGNED`属性，表示不运行负数，这大致可以让正数的上限提高一倍。

例如 TINYINT UNSIGNED 可以存储 0 ~ 255的，而 TINYINT的存储范围是 -128~127

> 有时候数据不可能为负数的时候就采用 这个属性把，记住我们的 `越小越好`原则哦。😁

### 实数类型

实数是带有小数部分的数字。然而，他们不只是为了储存小数部分；也可以使用DECIMAL储存比BIGINT还大的整数。FLOAT和DOUBLE类型支持浮点计算，但是会因为精度问题缺失一些数据，导致奇怪的结果。所以我们要计算很准确的小数的时候尽量使用 DECIMAL类型。例如财务数据什么的。

当然，如果我们的数据比较大的化，我们可以考虑使用BIGINT来代替DECIMAL ，将需要储存的货币单位根据小数来乘以相应的倍数就可以了。

### VARCHER和CHAR类型

VARCHER是变长字符串，他需要使用一个或者两个额外的字节记录字符串的长度，如果列的最大长度大于或等于255则需要两个，VARCHER 节省了储存空间，所以对性能也有帮助。但是由于是变长的，所以有时候内容发生改变的时候就需要做其他额外的操作了。

`InnoDb`会将过长的VARCHER变为BLOB类型

CHAR类型是定长的。对于经常变更的数据推荐使用CHAR类型，因为CHAR类型不容易产生碎片。或者是那些知道了长度的类型，例如MD5码。

CHAR类型会将末尾的空格去除。

## 创建高性能的索引

### 1、索引基础

mysql中的索引可以提高我们的查询效率，就好比是你在图书馆要找书，可以询问图书管理员通过各种标签后找到对应图书的区块一样，可以大大提高我们的效率。

在mysql中索引有这样的一个原则，`最左前缀原则`。

意思就是说，如果你建了  index(A,B,C)这样的多列索引的话，你如果查询条件的里面  是 A,B,C 或者 A,B或者A 都可以触发这个多列索引的。但是 如果是 A,C的话就会导致索引失效。

### 2、索引的类型

#### 2.1、B-Tree索引（B+Tree）

B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

一个简单的b-tree索引的抽象表示

![image-20210423215014809](C:\Users\陈俊宏\AppData\Roaming\Typora\typora-user-images\image-20210423215014809.png)

> B+Tree 为什么可以让访问数据更快?

B-Tree索引可以加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始搜索。

根节点的槽中存放了指向子节点中的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。

叶子节点比较特殊，他们的指针指向被索引的数据，而不是其他的节点页。

`B-Tree对索引列是顺序组织存储的`,所以很适合查找范围数据。

> 可以使用B-Tree的索引的查询类型

- 全值匹配
  - 意思就是和索引中的所有列都匹配，例如 索引是 index(A,B,C) 那么我们去查找  A= 1,B=2,C=3这样就是全值匹配。
  - A = 1 , B = 2, C = 3
- 匹配最左前缀
  - 还是上面那个索引 ，但是这次我们的条件是 A=1，`只使用了索引的第一列`
- 匹配列前缀
  - 和上面的那个有些相似，但是又有所不同 ，这个是 A like 'lk%'这样的以 某个字符串前缀开头的，而且也必须是索引的第一列.
  - A like 'Lk%'
- 匹配范围值
  - 使用索引的第一列去匹配 ，A <2
  - A < 2
- 精确匹配某一列并范围匹配另外一列
  - 使用索引的第一列去精确匹配然后去匹配第二列的范围
  - A = 1 And B < 2 
- 只访问索引的查询
  - 也称覆盖索引，这个我们下面讲 🤭

> 使用索引的限制有什么？

- 如果`不是从索引的最左列（第一列）`开始查找，则无法使用索引。
- `不能跳过索引中的列 `
  - 例如：A = 1 , C=3 
- `如果有某个列使用了范围查询，那么这个列后面的索引就会不能使用。`
  - A = 1 , B like 'lk%',C=3 这里的C=3在索引上的查找就会失效!

#### 2.2、哈希索引

哈希索引基于哈希表实现，只有精确的匹配索引才会让哈希索引生效。

在Mysql中只有Memory引擎支持显式的支持哈希索引。Memory引擎支持非唯一哈希索引的，如果多个列的哈希值相同，索引会以链表的方式，存放多个指针到哈希条目中。

> 哈希索引的查找速度非常的快，但是相对的他也有他的缺点

- 哈希索引只储存哈希值和行指针，不储存字段值，所以不能使用索引里面的值来避免读取行。
- 哈希索引的数据不是按照索引值顺序存储的，所以不能用以排序。
- 不支持部分索引列查找，因为哈希索引是计算整个内容来计算哈希值的。
  - 例如 index（A,B） 但是我们查找 A则无效。

> 在什么情况下使用哈希索引？

有时候我们分库分表了要查找在那个表里面，我们就可以使用这个哈希索引了。类似与java里面的HashMap

我们可以在innodb引擎里面 加一个hash字段来伪造hash索引, 例如 对键做  `CRC32`哈希 

```sql
SELECT id FROM url WHERE url ="http://www.baidu.com"
AND url_crc = CRC32("http://www.baidu.com");
```

然后使用触发器来维护更新这个值

可以使用 ：FNV64() MD5() SHA1() CRC32()作为哈希 ，MD5()和SHA1()是强类型的容易产生较长的字符串（比较起来也麻烦），但是FNV64是64位的哈希值，比CRC32更少的哈希冲突。

当然，这种哈希最好是在应用层面做；

### 3、索引的优点

因为索引是有顺序的，所以可以知道索引有这样的三个优点：

1. 索引可以大大减少服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以讲随机I/O变成顺序I/O

### 4、高性能的索引策略

#### 4.1、独立的列

这个指的是，如果查询中的列不是独立的，则mysql就不会使用索引。

独立的列是指`索引列不能是表达式的一部分，也不能是函数的一部分`

- 例如：

- ```sql
  SELECT actor_id FROM sa WHERE actor_id + 1 = 5;
  ```

- ```sql
  SELECT ... WHERE TODAYS(CURRENT_DATE) - TODAYS(date_col) <=10
  ```

我们的原则就是，将`索引列单独放在比较符号的一侧`

#### 4.2、前缀索引

有时候会有在很长的字符串上面创建的索引的需要。但是如果用整个字符串去做索引的话，那我们的储存成本就太高了，在比较的时候效率也不高。

所以就出现了前缀索引，有时候我们的字符串是长这样的：

- "act_home"
- "ack_home"
- "atk_df"

我们用肉眼就可以看出，我们其实只用比较前3个字符就可以判断了。所以我们也可以知道前缀索引的一些优点:

- 节省我们的索引空间。
- 提高索引效率

> 如何选择前缀索引的长度呢？

上面的例子我们是用肉眼看出来的是3位可以比较出来不同。但是在实际过程中我们却不能这样做。我们可以利用这样的语句

完整列的选择性计算

```sql
SELECT COUNT(distinct name)/COUNT(*) FROM user;
```

取多少位的选择性计算

```sql
SELECT COUNT(distinct LEFT(name,len))/COUNT(*) FROM user;
```

这样我们可以得到一个数字，这个数字就是对应的选择性，1是最高和最好的。随着索引长度的增加这个数字也会从 0增加，当然当长度大于某个点的时候，这个数字增加的速度就慢下来了。大概取多少还是要我们自己来判断。越接近完整列的选择性越好。

> 前缀索引存在的问题。

就是我们都是用前缀来进行分辨的，当前缀的数量分布均匀的时候，这个索引是非常好的，但是当我们的分布不均的时候，例如 "act"这个前缀开头的有 1w个 ,但是 "ack"前缀或者其他 的前缀的数量只有 2~3个的时候，我们索引的效果其实就微乎其微了，所以我们要尽量让索引分布的均匀；

> 创建前缀索引

```sql
ALTER TABLE user ADD index idx_name(name(2));
```

#### 4.3、多列索引

多列索引的理解经常犯的两个`错误`：

- 为每个列创建单独的索引
  - 这样做的性能，在大部分情况下并不能提高Mysql的查询效率,虽然Mysql在5.0支持了索引合并，但是还是会让情况变得复杂
- 按照错误的顺序创建索引

一般来说我们会将选择性最高的列放在前面，选择性比较低的列放在后面。

关于选择性的计算可以看前面的前缀索引的内容。

> 创建多列索引的方式

```sql
ALTER TABLE user ADD index idx_user(id,type,name);
```

#### 4.4、聚簇索引（主键相关）

聚簇索引并不是一种单独的索引类型，而是一种数据储存方式。

当表有聚簇索引的时候，他的数据行实际上存放在`索引的叶子页`上。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。

> 聚集的数据的优点

- 可以把相关的数据保存在一起。
  - 例如你可以通过用户的id来查询数据，这样就只用读取少数的数据页就可以获取到用户的信息
- 数据访问的更快。
  - 聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比非聚簇索引中查找要快。
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

> 聚簇索引的缺点

- 插入速度严重依赖插入顺序。
  - 因为每次插入都要取找到一个合适的地方取插入，这样的话按照主键插入是最快的。
- 更新聚簇索引的代价很高
  - 因为每次主键被更新的时候就会导致移动行，可能会导致页分裂问题。当行的主键值要求必须将这一行插入某个已满的页中的时候，存储引擎会将这个页分裂成两个页面来容纳该行，这就是页分裂操作，页分裂会导致占用更多的磁盘空间。

- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏的时候，或者由于页分裂导致数据不连续存储的时候。
- 二级索引可能比想象中大，因为在二级索引的叶子节点包含了引用行的主键列。

所以我们在选择主键的时候最好选择，`单调递增`的类型来作为主键。

**innodb中二级索引的叶子节点存储的不是行数据，而是聚簇索引的键值。**

#### 4.5、覆盖索引

因为mysql可以通过索引来直接获取数据，这样就可以不用去读取数据行了。如果索引的叶子节点中已经包含了要查询的数据，这样就不再需要读取数据行了不是嘛？😂

**如果一个索引包含所有需要查询的字段的值，我们就称之为"覆盖索引".**

> 覆盖索引的好处

- 索引的条目通常远小于数据行大小，所以如果只需要读取索引，那么mysql就会极大的减少数据访问量。
- 因为索引是顺序存储的，所以查找一些数据的时候，可以避免磁盘的随机 I/O。
- 如果二级索引可以覆盖查询，就可以避免对主键索引的二次查询！

一个小栗子：

如果你有这样的一条语句要执行

```sql
SELECT * FROM user where name = 'coco' AND title like '%goodboy%';
```

当然这里我们即使在name列建立了索引，仍然还是无法生效，可能有这样两个原因：

1. 没有任何的索引可以覆盖这个查询。 因为是 `*`，不过我们还是有办法的毕竟我们有一个索引可以做一个过滤。
2. 索引中不能执行like操作。mysql中可以做 最左前缀匹配的like比较，因为可以将该操作变化为比较的形式。

我们可以这样做：

建立这样的索引 `index(name,title,userId)` 【注意顺序】然后执行下面的语句：

```sql
SELECT * FROM user
JOIN(
	SELECT userId
    FROM user
    WHERE name = 'coco' AND title LIKE '%goodboy%'
) as t1 ON(t1.userId = user.userId);
```

这样的方式叫做延迟查询。我们可以利用覆盖索引在查询的第一阶段将userId查询出来，然后再根据userId主键去查询。虽然无法覆盖整个查询，但是已经比之前好了不少了。

### 5、使用索引扫描来做排序

mysql有两种方式来生成有序的结果，一种是通过排序操作，或者是按索引顺序扫描；如果EXPLAIN出来的type列的值为index，则说明使用了索引扫描来做排序。

> 使用索引来排序的条件

- 索引的列的顺序和`ORDER BY`的顺序完全一致的时候，并且列的排序方向都一致的时候。

- 关联多表的时候，`ORDER BY`子句引用的字段全部为第一个表时。

- 满足索引的最左前缀的要求。

  - 有一种情况下可以不满足最左前缀

    - 前导列为常量的时候

  - ```sql
    SELECT user_id,dept_id FROM user
    WHERE user_number = 5
    ORDER BY user_id,dept_id
    ```

> 导致无法使用索引的原因

- 选择的列的排序方向不一致
- 使用了不在索引中的列
- 无法组合成索引的最左前缀原则
- 使用了范围条件

### 6、索引和锁

索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行。

- innoDB只有在访问行的时候会对其加锁，而索引能够减InnoDB访问的行数，从而减少锁的数量。

但是有的时候我们的索引并不能完全过滤无效的行，所以我们的行还是存在被锁住的可能。

### 7、小技巧

可以使用 `in()`来代替一些小范围的条件。这样我们可以让我们的最左匹配原则依然可以匹配到`in()`这样的后面的列的索引。因为`in()`相当于多值等于。 

## 查询性能优化

### 为什么查询会慢？

- 向数据库请求了不需要的数据
  - 查询不需要的记录
  - 多表关联时返回全部列
  - 总是取出全部列
- 扫描了额外的列

## 参考资料

1. 《高性能Mysql 》 Baron Scbwartz
2. "MVCC实现原理" 作者：爱情小傻蛋
   链接：https://www.jianshu.com/p/8845ddca3b23
   来源：简书
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。